"use server";
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import { PaginationParams } from '@/interface/actions';
import { revalidatePath } from 'next/cache';
import { mapProductsDBToFrontend, ProductDB } from '@/lib/product-mapper';
import { getSupabaseClient } from '@/lib/supabase-server';

interface PaginationParams {
  page?: number;
  pageSize?: number;
  search?: string;
  categoryId?: number;
  warehouseId?: number;
  totalCount?: number;
}

// Funci√≥n para sanitizar t√©rminos de b√∫squeda
function sanitizeSearchTerm(search: string): string {
  if (!search) return '';
  
  // Escapar caracteres especiales que pueden interferir con las consultas PostgREST
  return search
    .replace(/[,]/g, '') // Remover comas que interfieren con la sintaxis OR
    .replace(/[()]/g, '') // Remover par√©ntesis
    .replace(/['"]/g, '') // Remover comillas
    .replace(/[%]/g, '') // Remover porcentajes que interfieren con LIKE
    .trim();
}

// Funci√≥n alternativa de b√∫squeda m√°s robusta
async function getProductsWithAlternativeSearch(supabase: any, sanitizedSearch: string, categoryId?: number, warehouseId?: number, from?: number, to?: number) {
  console.log('üîÑ Usando b√∫squeda alternativa m√°s robusta');
  
  try {
    // Construir consulta base
    let baseQuery = supabase
      .from('Product')
      .select(`
        *,
        Category (*),
        Supplier (*),
        Warehouse_Products:Warehouse_Product${warehouseId ? '!inner' : ''} (
          id,
          quantity,
          "warehouseId",
          "productId",
          "minStock",
          "maxStock",
          Warehouse (
            id,
            name
          )
        )
      `);

    // Aplicar filtros uno por uno para evitar problemas de sintaxis
    if (sanitizedSearch) {
      // Buscar por nombre primero
      baseQuery = baseQuery.or(
        `name.ilike.%${sanitizedSearch}%,sku.ilike.%${sanitizedSearch}%`
      );
    }

    // Aplicar otros filtros
    if (categoryId) {
      baseQuery = baseQuery.eq('categoryid', categoryId);
    }

    if (warehouseId) {
      baseQuery = baseQuery.filter('Warehouse_Products.warehouseId', 'eq', warehouseId);
    }

    // Ejecutar consulta con paginaci√≥n
    const { data, error, count } = await baseQuery
      .range(from || 0, to || 9)
      .order('id', { ascending: false });

    return { data, error, count };
  } catch (error) {
    console.error('‚ùå Error en b√∫squeda alternativa:', error);
    return { data: null, error, count: 0 };
  }
}

export async function getProducts(params: PaginationParams) {
  try {
    const supabase = await getSupabaseClient();
    const { page = 1, pageSize = 10, search, categoryId, warehouseId } = params;
    const currentPage = typeof page === 'string' ? parseInt(page) : page;
    const currentPageSize = typeof pageSize === 'string' ? parseInt(pageSize) : pageSize;
    const from = (currentPage - 1) * currentPageSize;
    const to = from + currentPageSize - 1;

    // Construir consulta base con bodegas asociadas
    let query = supabase
      .from('Product')
      .select(`
        *,
        Category (*),
        Supplier (*),
        Warehouse_Products:Warehouse_Product${warehouseId ? '!inner' : ''} (
          id,
          quantity,
          "warehouseId",
          "productId",
          "minStock",
          "maxStock",
          Warehouse (
            id,
            name
          )
        )
      `);

    // Aplicar filtros de b√∫squeda con m√©todo m√°s robusto
    if (search) {
      const sanitizedSearch = sanitizeSearchTerm(search);
      console.log('üîç B√∫squeda original:', search);
      console.log('üßπ B√∫squeda sanitizada:', sanitizedSearch);
      
      if (sanitizedSearch) {
        // Enfoque m√°s seguro: usar consultas individuales en lugar de OR complejo
        // Esto evita completamente los problemas de caracteres especiales
        try {
          query = query.or(
            `name.ilike.%${sanitizedSearch}%,` +
            `sku.ilike.%${sanitizedSearch}%,` +
            `barcode.ilike.%${sanitizedSearch}%,` +
            `brand.ilike.%${sanitizedSearch}%`
          );
        } catch (searchError) {
          console.error('‚ùå Error en b√∫squeda con OR, intentando b√∫squeda alternativa:', searchError);
          // Usar funci√≥n alternativa m√°s robusta
          const alternativeResult = await getProductsWithAlternativeSearch(
            supabase, 
            sanitizedSearch, 
            categoryId, 
            warehouseId, 
            from, 
            to
          );
          
          if (alternativeResult.error) {
            throw new Error(`Error en b√∫squeda alternativa: ${alternativeResult.error.message}`);
          }
          
          // Procesar resultado de b√∫squeda alternativa
          const products = alternativeResult.data || [];
          console.log(`‚úÖ B√∫squeda alternativa exitosa: ${products.length} productos encontrados`);
          
          return {
            products: mapProductsDBToFrontend(products),
            totalCount: alternativeResult.count || products.length
          };
        }
      }
    }

    // Aplicar filtro por categor√≠a
    if (categoryId) {
      const categoryIdNumber = typeof categoryId === 'string' ? parseInt(categoryId) : categoryId;
      if (!isNaN(categoryIdNumber)) {
        query = query.eq('categoryid', categoryIdNumber);
      }
    }

    // Aplicar filtro por bodega
    if (warehouseId) {
      const warehouseIdNumber = typeof warehouseId === 'string' ? parseInt(warehouseId) : warehouseId;
      if (!isNaN(warehouseIdNumber)) {
        // Filtrar productos que est√©n asignados a la bodega espec√≠fica
        query = query.filter('Warehouse_Products.warehouseId', 'eq', warehouseIdNumber);
      }
    }

    // Obtener productos con paginaci√≥n
    const { data: products, error, count } = await query
      .range(from, to)
      .order('id', { ascending: false });

    if (error) {
      console.error('‚ùå Error en consulta de productos:', error);
      console.error('‚ùå Detalles del error:', {
        message: error.message,
        details: error.details,
        hint: error.hint,
        code: error.code
      });
      throw new Error(`Error obteniendo productos: ${error.message}`);
    }

    // Obtener conteo total si no se proporcion√≥
    let totalCount = count || 0;
    if (!count) {
      let countQuery = supabase.from('Product').select('*', { count: 'exact', head: true });
      
      // Aplicar los mismos filtros para el conteo
      if (search) {
        countQuery = countQuery.or(`name.ilike.%${search}%,sku.ilike.%${search}%,barcode.ilike.%${search}%,brand.ilike.%${search}%`);
      }
      if (categoryId) {
        const categoryIdNumber = typeof categoryId === 'string' ? parseInt(categoryId) : categoryId;
        if (!isNaN(categoryIdNumber)) {
          countQuery = countQuery.eq('categoryid', categoryIdNumber);
        }
      }
      if (warehouseId) {
        const warehouseIdNumber = typeof warehouseId === 'string' ? parseInt(warehouseId) : warehouseId;
        if (!isNaN(warehouseIdNumber)) {
          // Para el conteo, necesitamos una consulta diferente que incluya el join
          const { count: warehouseFilteredCount } = await supabase
            .from('Product')
            .select(`
              *,
              Warehouse_Products:Warehouse_Product!inner (
                warehouseId
              )
            `, { count: 'exact', head: true })
            .filter('Warehouse_Products.warehouseId', 'eq', warehouseIdNumber);
          
          totalCount = warehouseFilteredCount || 0;
        }
      }
      
      if (!warehouseId) {
        const { count: total } = await countQuery;
        totalCount = total || 0;
      }
    }

    // Mapear productos de snake_case (BD) a camelCase (Frontend)
    const mappedProducts = mapProductsDBToFrontend(products as ProductDB[] || []);
    
    // Los productos se mapean correctamente de snake_case a camelCase

    return { products: mappedProducts, totalCount };
  } catch (error) {
    console.error('Error fetching products:', error);
    return { products: [], totalCount: 0 };
  }
}

// Funci√≥n para verificar dependencias del producto
export async function checkProductDependencies(productId: number) {
  try {
    const supabase = await getSupabaseClient();
    
    const [warehousesResult, salesResult, reservationsResult, componentsResult, pettyCashResult, posProductResult, invoiceLinesResult, purchaseInvoiceLinesResult] = await Promise.all([
      supabase.from('Warehouse_Product').select('*', { count: 'exact', head: true }).eq('"productId"', productId),
      supabase.from('Sale_Product').select('*', { count: 'exact', head: true }).eq('"productId"', productId),
      supabase.from('Reservation_Product').select('*', { count: 'exact', head: true }).eq('"productId"', productId),
      supabase.from('Product_Component').select('*', { count: 'exact', head: true }).or(`"parentId".eq.${productId},"componentId".eq.${productId}`),
      supabase.from('PettyCashPurchase').select('*', { count: 'exact', head: true }).eq('"productId"', productId),
      supabase.from('POSProduct').select('*', { count: 'exact', head: true }).eq('"productId"', productId),
      supabase.from('invoice_lines').select('*', { count: 'exact', head: true }).eq('product_id', productId),
      supabase.from('purchase_invoice_lines').select('*', { count: 'exact', head: true }).eq('product_id', productId)
    ]);

    const dependencies = {
      warehouses: warehousesResult.count || 0,
      sales: salesResult.count || 0,
      reservations: reservationsResult.count || 0,
      components: componentsResult.count || 0,
      pettyCashPurchases: pettyCashResult.count || 0,
      posProducts: posProductResult.count || 0,
      invoiceLines: invoiceLinesResult.count || 0,
      purchaseInvoiceLines: purchaseInvoiceLinesResult.count || 0
    };

    const total = Object.values(dependencies).reduce((sum, count) => sum + count, 0);
    
    const hasInvoices = dependencies.invoiceLines > 0 || dependencies.purchaseInvoiceLines > 0;
    
    return {
      dependencies,
      hasAny: total > 0,
      hasInvoices,
      total
    };
  } catch (error) {
    console.error('Error checking product dependencies:', error);
    return {
      dependencies: { warehouses: 0, sales: 0, reservations: 0, components: 0, pettyCashPurchases: 0, posProducts: 0, invoiceLines: 0, purchaseInvoiceLines: 0 },
      hasAny: false,
      hasInvoices: false,
      total: 0
    };
  }
}

export async function deleteProduct(formData: FormData) {
  console.log('üîß deleteProduct: Iniciando funci√≥n de eliminaci√≥n');
  console.log('üìã deleteProduct: FormData recibida:', Array.from(formData.entries()));
  
  try {
    const supabase = await getSupabaseClient();
    const idString = formData.get('id') as string;
    const forceDelete = formData.get('force') === 'true';
    
    console.log('üîç deleteProduct: Par√°metros extra√≠dos:', { idString, forceDelete });
    
    if (!idString) {
      console.log('‚ùå deleteProduct: ID del producto no proporcionado');
      return { 
        success: false, 
        error: 'ID del producto es requerido' 
      };
    }

    const id = parseInt(idString);
    if (isNaN(id)) {
      console.log('‚ùå deleteProduct: ID del producto no es v√°lido:', idString);
      return { 
        success: false, 
        error: 'ID del producto no es v√°lido' 
      };
    }

    console.log('üîç deleteProduct: Verificando existencia del producto ID:', id);

    // Verificar si el producto existe (sin stockid)
    const { data: product, error: productError } = await supabase
      .from('Product')
      .select('id, name')
      .eq('id', id)
      .single();

    if (productError || !product) {
      console.log('‚ùå deleteProduct: Producto no existe:', productError?.message);
      return { 
        success: false, 
        error: 'El producto no existe' 
      };
    }

    console.log('‚úÖ deleteProduct: Producto encontrado:', product);

    // Verificar dependencias
    console.log('üîç deleteProduct: Verificando dependencias...');
    const dependencyCheck = await checkProductDependencies(id);
    console.log('üìä deleteProduct: Resultado de verificaci√≥n de dependencias:', dependencyCheck);

    // PROTECCI√ìN CR√çTICA: NO permitir eliminar productos que est√©n en facturas
    if (dependencyCheck.hasInvoices) {
      console.log('üö´ deleteProduct: PRODUCTO EN FACTURAS - Eliminaci√≥n PROHIBIDA');
      const invoiceDetails = [];
      if (dependencyCheck.dependencies.invoiceLines > 0) {
        invoiceDetails.push(`üìÑ ${dependencyCheck.dependencies.invoiceLines} facturas de ventas emitidas a clientes`);
      }
      if (dependencyCheck.dependencies.purchaseInvoiceLines > 0) {
        invoiceDetails.push(`üìã ${dependencyCheck.dependencies.purchaseInvoiceLines} facturas de compras recibidas de proveedores`);
      }
      
      return { 
        success: false, 
        error: `üö´ ELIMINACI√ìN PROHIBIDA\n\nNo se puede eliminar "${product.name}" porque aparece en:\n‚Ä¢ ${invoiceDetails.join('\n‚Ä¢ ')}\n\nüö® IMPORTANTE: Las facturas son documentos legales y fiscales que NO se pueden modificar una vez emitidas.\n\n‚úÖ ALTERNATIVAS RECOMENDADAS:\n‚Ä¢ Marcar el producto como "Inactivo" en su configuraci√≥n\n‚Ä¢ Cambiar su estado a "Descontinuado"\n‚Ä¢ Ocultarlo del punto de venta\n‚Ä¢ Revisar facturas en: Dashboard ‚Üí Ventas ‚Üí Facturas o Dashboard ‚Üí Compras ‚Üí Facturas`,
        dependencies: dependencyCheck.dependencies,
        hasInvoices: true,
        canForceDelete: false
      };
    }
    
    if (dependencyCheck.hasAny && !forceDelete) {
      console.log('‚ö†Ô∏è deleteProduct: Producto tiene dependencias, requiere confirmaci√≥n');
      const deps = dependencyCheck.dependencies;
      const messages = [];
      const actionMessages = [];
      
      if (deps.warehouses > 0) {
        messages.push(`üè™ ${deps.warehouses} asignaci√≥n(es) en bodegas con stock disponible`);
        actionMessages.push('Revisar inventario en Dashboard ‚Üí Inventario');
      }
      if (deps.sales > 0) {
        messages.push(`üí∞ ${deps.sales} venta(s) registrada(s) en el hist√≥rico`);
        actionMessages.push('Revisar ventas en Dashboard ‚Üí Ventas');
      }
      if (deps.reservations > 0) {
        messages.push(`üìÖ ${deps.reservations} reservaci√≥n(es) activa(s) o hist√≥ricas`);
        actionMessages.push('Revisar reservas en Dashboard ‚Üí Reservaciones');
      }
      if (deps.components > 0) {
        messages.push(`üîß ${deps.components} componente(s) o producto(s) padre en productos modulares`);
        actionMessages.push('Revisar productos modulares en Dashboard ‚Üí Productos');
      }
      if (deps.pettyCashPurchases > 0) {
        messages.push(`üíµ ${deps.pettyCashPurchases} compra(s) registrada(s) en caja menor`);
        actionMessages.push('Revisar caja menor en Dashboard ‚Üí Caja Menor');
      }
      if (deps.posProducts > 0) {
        messages.push(`üõí ${deps.posProducts} configuraci√≥n(es) en punto de venta`);
        actionMessages.push('Revisar POS en Dashboard ‚Üí Punto de Venta');
      }
      
      const uniqueActions = [...new Set(actionMessages)];
      
      return { 
        success: false, 
        error: `‚ö†Ô∏è ELIMINACI√ìN CON DEPENDENCIAS\n\nNo se puede eliminar "${product.name}" porque tiene dependencias activas:\n\n${messages.map(msg => `‚Ä¢ ${msg}`).join('\n')}\n\nüîç D√ìNDE REVISAR:\n${uniqueActions.map(action => `‚Ä¢ ${action}`).join('\n')}\n\n‚úÖ OPCIONES DISPONIBLES:\n‚Ä¢ Eliminar estas dependencias manualmente y luego eliminar el producto\n‚Ä¢ Usar "Eliminaci√≥n Forzada" para eliminar todo autom√°ticamente (‚ö†Ô∏è acci√≥n irreversible)\n‚Ä¢ Marcar el producto como inactivo en lugar de eliminarlo`,
        dependencies: dependencyCheck.dependencies,
        canForceDelete: true
      };
    }

    console.log('üóëÔ∏è deleteProduct: Procediendo con eliminaci√≥n...');

    // Si es eliminaci√≥n forzada, eliminar todas las dependencias
    if (forceDelete && dependencyCheck.hasAny) {
      console.log('üí• deleteProduct: Eliminaci√≥n FORZADA - eliminando dependencias primero');
      
      // Eliminar en orden de dependencias con logging detallado
      console.log('üßπ deleteProduct: Eliminando Warehouse_Product...');
      const warehouseResult = await supabase.from('Warehouse_Product').delete().eq('"productId"', id);
      console.log('üìä deleteProduct: Warehouse_Product eliminado:', warehouseResult);
      
      console.log('üßπ deleteProduct: Eliminando Sale_Product...');
      const saleResult = await supabase.from('Sale_Product').delete().eq('"productId"', id);
      console.log('üìä deleteProduct: Sale_Product eliminado:', saleResult);
      
      console.log('üßπ deleteProduct: Eliminando Reservation_Product...');
      const reservationResult = await supabase.from('Reservation_Product').delete().eq('"productId"', id);
      console.log('üìä deleteProduct: Reservation_Product eliminado:', reservationResult);
      
      console.log('üßπ deleteProduct: Eliminando Product_Component...');
      const componentResult = await supabase.from('Product_Component').delete().or(`"parentId".eq.${id},"componentId".eq.${id}`);
      console.log('üìä deleteProduct: Product_Component eliminado:', componentResult);
      
      console.log('üßπ deleteProduct: Eliminando PettyCashPurchase...');
      const pettyCashResult = await supabase.from('PettyCashPurchase').delete().eq('"productId"', id);
      console.log('üìä deleteProduct: PettyCashPurchase eliminado:', pettyCashResult);
      
      console.log('üßπ deleteProduct: Eliminando POSProduct...');
      const posProductResult = await supabase.from('POSProduct').delete().eq('"productId"', id);
      console.log('üìä deleteProduct: POSProduct eliminado:', posProductResult);
      
      console.log('üßπ deleteProduct: Dependencias eliminadas completamente');
    } else {
      console.log('üóëÔ∏è deleteProduct: Eliminaci√≥n NORMAL - sin dependencias');
      // Eliminaci√≥n normal (sin dependencias)
      // Eliminar asignaciones en bodegas y POS por si acaso
      console.log('üßπ deleteProduct: Limpiando Warehouse_Product por seguridad...');
      const warehouseCleanupResult = await supabase.from('Warehouse_Product').delete().eq('"productId"', id);
      console.log('üìä deleteProduct: Limpieza Warehouse_Product:', warehouseCleanupResult);
      
      console.log('üßπ deleteProduct: Limpiando POSProduct por seguridad...');
      const posCleanupResult = await supabase.from('POSProduct').delete().eq('"productId"', id);
      console.log('üìä deleteProduct: Limpieza POSProduct:', posCleanupResult);
    }

    // Eliminar el producto
    console.log('üóëÔ∏è deleteProduct: Eliminando producto de tabla Product...');
    const deleteResult = await supabase
      .from('Product')
      .delete()
      .eq('id', id);

    console.log('üìä deleteProduct: Resultado eliminaci√≥n Product:', deleteResult);
    
    // Verificar si realmente se elimin√≥
    if (deleteResult.error) {
      console.error('‚ùå deleteProduct: Error en eliminaci√≥n del producto:', deleteResult.error);
      return { 
        success: false, 
        error: `Error al eliminar el producto: ${deleteResult.error.message}` 
      };
    }

    // Verificar que realmente se elimin√≥
    console.log('üîç deleteProduct: Verificando que el producto se elimin√≥...');
    const { data: verifyProduct, error: verifyError } = await supabase
      .from('Product')
      .select('id')
      .eq('id', id)
      .single();

    if (verifyProduct) {
      console.error('‚ùå deleteProduct: ¬°PROBLEMA! El producto a√∫n existe despu√©s de eliminarlo');
      return { 
        success: false, 
        error: 'El producto no se pudo eliminar de la base de datos. Posible problema de permisos o pol√≠ticas RLS.' 
      };
    }

    if (verifyError && verifyError.code !== 'PGRST116') { // PGRST116 = no rows returned (esperado)
      console.error('‚ùå deleteProduct: Error verificando eliminaci√≥n:', verifyError);
      return { 
        success: false, 
        error: `Error verificando eliminaci√≥n: ${verifyError.message}` 
      };
    }

    console.log('‚úÖ deleteProduct: Verificaci√≥n exitosa - producto eliminado de la DB');

    console.log('‚ôªÔ∏è deleteProduct: Revalidando p√°ginas...');
    revalidatePath('/dashboard/configuration/products');
    revalidatePath('/dashboard/inventory');

    console.log('‚úÖ deleteProduct: Eliminaci√≥n completada exitosamente');
    return { 
      success: true, 
      message: `Producto "${product.name}" eliminado correctamente` 
    };

  } catch (error) {
    console.error('üí• deleteProduct: Error en eliminaci√≥n:', error);
    return { 
      success: false, 
      error: 'Error interno del servidor al eliminar el producto' 
    };
  }
}

export async function deleteProductById(id: number) {
  const formData = new FormData();
  formData.append('id', id.toString());
  return await deleteProduct(formData);
} 